<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>druid中GroupbyQuery查询流程解析 | Big Face Cat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="整体概述​    从之前broker和his等节点对流程可知，对于所有的查询不同处在于构建的queryRunner不同，queryRunner本身可以看做一个函数，不同的查询类型对应的queryRunner不同，这一节将对其中几个查询类型进行解析，详解各种查询是如何进行的。  ​    在his端和realtime端的查询步骤如上图所示，整体处理逻需要关注的三个方法是：  ​    QueryFa">
<meta property="og:type" content="article">
<meta property="og:title" content="druid中GroupbyQuery查询流程解析">
<meta property="og:url" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Big Face Cat">
<meta property="og:description" content="整体概述​    从之前broker和his等节点对流程可知，对于所有的查询不同处在于构建的queryRunner不同，queryRunner本身可以看做一个函数，不同的查询类型对应的queryRunner不同，这一节将对其中几个查询类型进行解析，详解各种查询是如何进行的。  ​    在his端和realtime端的查询步骤如上图所示，整体处理逻需要关注的三个方法是：  ​    QueryFa">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219221718521.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222536470.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222559315.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222612118.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222632657.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222652499.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222737925.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222754027.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222805541.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222820888.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222832663.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222847160.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222908342.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222931539.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222958170.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223011452.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223021255.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223029452.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223040244.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223050272.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223115467.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223143477.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223212039.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223244113.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223302789.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223320717.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223344867.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223413572.png">
<meta property="og:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223434957.png">
<meta property="article:published_time" content="2022-02-19T14:23:52.000Z">
<meta property="article:modified_time" content="2022-02-19T14:36:19.967Z">
<meta property="article:author" content="Lime">
<meta property="article:tag" content="druid">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219221718521.png">
  
    <link rel="alternate" href="/atom.xml" title="Big Face Cat" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Big Face Cat</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-druid中GroupbyQuery查询流程解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2022-02-19T14:23:52.000Z" itemprop="datePublished">2022-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      druid中GroupbyQuery查询流程解析
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h4><p>​    从之前broker和his等节点对流程可知，对于所有的查询不同处在于构建的queryRunner不同，queryRunner本身可以看做一个函数，不同的查询类型对应的queryRunner不同，这一节将对其中几个查询类型进行解析，详解各种查询是如何进行的。</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219221718521.png" alt="image-20220219221718521"></p>
<p>​    在his端和realtime端的查询步骤如上图所示，整体处理逻需要关注的三个方法是：</p>
<ul>
<li><p>​    QueryFactory.createRunner</p>
</li>
<li><p>​    QueryFactory.mergeRunners</p>
</li>
<li><p>​    QueryToolChest.mergeResult</p>
<p>在查询流程当中，会按照先后顺序调用这三个方法，返回broker端之后还会掉用一次QueryToolChest.mergeResult方法将各个节点的结果再进行一次merge。所以下面的代码主要会解析不同查询中这三个方法的执行逻辑。</p>
</li>
</ul>
<p>​    groupByQueryRunner根据query会选择对应的strategy，一般来说，默认会选择v2版本，可以在配置文件中指定druid.lucene.query.groupBy.defaultStrategy来指定默认的策略。这里也只会对V2版本策略进行一个说明，groupbQueryFactory调用createRunner方法查询的会调用GroupByStrategy的process进行，现在对GroupByStrategyV2的策略进行说明，执行入口是GroupByQueryEngineV2.process()方法，跟其他查询一样也是会调用process方法对每个segment进行查询，然后调用factory.mergeRunners方法对QueryRunner集合进行聚合。</p>
<h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><h5 id="关键接口"><a href="#关键接口" class="headerlink" title="关键接口"></a>关键接口</h5><p>在对groupby的整个流程进行解析之前，先看看在druid在groupby中抽象出的两个类和接口，方便后续理解</p>
<ol>
<li><p>grouper接口</p>
</li>
<li><p>CloseableGrouperIterator</p>
</li>
</ol>
<p>​    首先是grouper接口：</p>
<p>​    grouper接口在整个groupby流程中的作用是对groupby的维度进行分组以及聚合计算。grouper接口的包含的方法和其内部接口如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222536470.png" alt="image-20220219222536470"></p>
<p>关键方法为：</p>
<ul>
<li>init方法：初始化Grouper对象</li>
<li>aggregate：使用提供的键值聚合当前行。</li>
<li>iterator：将完成聚合运算的所有行生成的groupby结果转换为可迭代的聚合结果。</li>
</ul>
<p>grouper使用的流程如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222559315.png" alt="image-20220219222559315"></p>
<p>​    其次是CloseableGrouperIterator接口，它是用于迭代groupby完成之后的结果数据，继承于Iterator接口，他的成员变量和构造方法如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222612118.png" alt="image-20220219222612118"></p>
<p>​    iterator是通过调用grouper.iterator方法生成，transformer变量是一个Function，这个接口用于将grouper生成的结果进行一个转化操作。</p>
<p>​    下面通过对groupby查询整体流程的一个解析来看看tindex是如何完成groupby操作的。</p>
<h5 id="GroupByQueryEngineV2-process解析"><a href="#GroupByQueryEngineV2-process解析" class="headerlink" title="GroupByQueryEngineV2.process解析"></a>GroupByQueryEngineV2.process解析</h5><p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222632657.png" alt="image-20220219222632657"></p>
<p>​    V2版本是基于堆外内存计算的，intermediateResultsBufferPool表示堆外内存池。</p>
<p>​    groupby每个segment的计算逻辑基本上是在GroupByQueryEngineV2这个类中，处理流程前半部分和TimeseriesQuery一样，通过对query中interval的解析获取cursors，通过cursors来操作数据，groupQuery查询会先根据要分组的维度通过cursor获取DimensionSelector集合，这些DimensionSelector用于查询维度字段的值，具体的groupby的逻辑在GroupByEngineIterator这个类中，接下来详细解读一下tindex是如何进行groupby的。</p>
<p>​    在CloseableGrouperIterator中，进行groupby之前要先调用initNewDelegate()，这里面会初始化Grouper对象，groupby的核心逻辑就封装在这个类中。</p>
<p>​    process方法整体流程如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222652499.png" alt="image-20220219222652499"></p>
<p>​    其中对cursor进行查询操作的操作如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222737925.png" alt="image-20220219222737925"></p>
<p>​    makeDimensionSelector方法是获得每个groupby字段的selector，这部分逻辑是将分组字段的查询器selector都构建出来，最终构建出GroupByEngineIterator，GroupByEngineIterator会封装对segment进行groupby的逻辑，下面篇幅将讲解GroupByEngineIterator中的逻辑，GroupByEngineIterator继承于Iterator，主要看next方法和hasnext方法，从中可以看到获取row是通过CloseableGrouperIterator对象。这个对象是从GroupByEngineIterator.initNewDelegate()方法创建得到，initNewDelegate流程如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222754027.png" alt="image-20220219222754027"></p>
<p>​    此方法会先初始化一个grouper，然后调用aggregateSingleValueDims或者aggregateMultiValueDims计算聚合结果，最后返回CloseableGrouperIterator,在tindex中使用groupby现在有两种grouper，分别是：BufferHashGrouper和BufferArrayGrouper，使用那种grouper是在代码中是通过GroupByQueryEngineV2.isArrayAggregateApplicable方法进行判断，使用BufferArrayGrouper的条件是groupby的维度只有一个，并且能够拿到这个维度的基数以及类型占用长度，同时当前的buffer容量能够支撑这些维度存储就会选用BufferArrayGrouper，其他情况下都会使用BufferHashGrouper。</p>
<p>​    其中，Grouper根据通常从ColumnSelectorFactory获得的行聚合度量，这些行位于某个外部驱动程序传入的分组键下。聚合完成后，它们还可以迭代分组行。它们的工作方式有点类似于键类型到聚合值的映射。Grouper接口如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222805541.png" alt="image-20220219222805541"></p>
<p>​    现在详解一下BufferHashGrouper实现,主要是计算出需要申请的内存大小，生成一个ByteBufferHashTable，这是一个hash表，用于存放各个分组的键和key值，开始查询之后会根据groupby的多列分区不同的分区会会被分步到这个hash表当中。它继承于AbstractBufferHashGrouper。</p>
<p>​    首先是构造方法：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222820888.png" alt="image-20220219222820888"></p>
<p>​    其中maxLoadFactor参数表示加载因子，就是hash表中存储的关键字个数，与可以散列位置的比值，这个值越大说明发生hash碰撞几率会越大。默认为0.7。initialBuckets表示初始化的桶的个数，在进行groupby的过程中，每个分组key组成的唯一值确定一个bucket。bucketSize表示每个bucket占用的字节大小，计算逻辑如上，比较简单就是一个HASH_SIZE（这里是int类型占用长度）+维度的数量+每个聚合函数结果占用的字节数量。</p>
<p>​    init方法：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222832663.png" alt="image-20220219222832663"></p>
<p>​    在init方法中主要是初始化hashTable，根据构造函数中已经初始化的配置参数信息，生成hashTable，主要步骤如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222847160.png" alt="image-20220219222847160"></p>
<ol>
<li>计算hashtable占用的size</li>
</ol>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222908342.png" alt="image-20220219222908342"></p>
<ol start="2">
<li>分别计算出hashTableBuffer和offsetList。</li>
</ol>
<p>​    hashTableBuffer表示整个hashtable的存储空间。</p>
<p>​    offsetList用于跟踪已用bucket的偏移量。当通过initializeNewBucketKey初始化新bucket时，将向该列表添加一个偏移量。</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222931539.png" alt="image-20220219222931539"></p>
<ol start="3">
<li><p>初始化hashTable(并非jdk中的hashtable，而是druid中使用堆外内存抽象出的hash表实现),在对grouper初始化完成之后，执行聚合计算</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219222958170.png" alt="image-20220219222958170"></p>
</li>
</ol>
<p>​    如果都是单值列进行聚合操作调用aggregateSingleValueDims方法，否则调用aggregateMultiValueDims方法，这里对HashAggregateIterator中的aggregateSingleValueDims方法进行一个解析：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223011452.png" alt="image-20220219223011452"></p>
<p>​    代码很简单，是对cursor对象进行一个迭代通过selectors查询出groupby的键值的id，构建keyBuffer，keybuffer中保存了当前的groupby的key信息，然后调用grouper的aggregate方法进行聚合，最后调用cursor.advance使cursor向前进一步。循环直到cursor无法迭代。</p>
<p>​    现在解析一下aggregate方法，aggregate方法是对数据进行聚合，底层调用的是</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223021255.png" alt="image-20220219223021255"></p>
<p>在BufferHashGrouper中的实现如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223029452.png" alt="image-20220219223029452"></p>
<p>​    入参key就是在aggregateSingleValueDims构建的keybuffer，而keyhash是将keybuffer进行hash之后的一个int值，方法首先会将keybuffer转化为一个bytebuffer并且对它进行一个校验，然后调用hashtable的findBucketWithAutoGrowth，拿到当前key对应的bucket位置。findBucketWithAutoGrowth是通过key值获取当前bucket位置，如果hashtable容量不够还会进行扩容，这里不做讲解。如果当前bucket还没有被占用，则调用initializeNewBucketKey初始化一个新的bucketkey，并且调用当前query的所有aggregator的init方法对agg进行一个init初始化操作，最后再调用每个aggregator的aggregate方法进行运算。</p>
<p>​    聚合完成之后会返回一个可迭代的结果，通过如下方式</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223040244.png" alt="image-20220219223040244"></p>
<p>​    其中CloseableGrouperIterator实际上是对grouper的一个封装代理，实际上最终调用的还是grouper的迭代逻辑，grouper中的iterator方法可以生成一个可迭代对象，这个迭代对象即可以迭代出当前聚合查询完成之后的结果，在HashBufferGroup中有对应的实现（这里是不带排序的处理逻辑）：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223050272.png" alt="image-20220219223050272"></p>
<p>​    通过对offsetList的遍历拿到当前hashtable中存在的所有的数据并且通过bucketEntryForOffset生成Entry对象，Entry中保存了groupby之后的聚合结果。最后在通过CloseableGrouperIterator转化成为MapBasedRow返回。这就是整个groupby的process部分重要逻辑。</p>
<h5 id="GroupByMergingQueryRunnerV2-run解析"><a href="#GroupByMergingQueryRunnerV2-run解析" class="headerlink" title="GroupByMergingQueryRunnerV2.run解析"></a>GroupByMergingQueryRunnerV2.run解析</h5><p>​    在所有的QueryRunner创建完成之后，会调用QueryFactory的mergeRunners合并这些QueryRunners,具体实现为GroupByMergingQueryRunnerV2，在这之中的成员如下：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223115467.png" alt="image-20220219223115467"></p>
<ul>
<li>config：groupby查询的配置信息</li>
<li>queryables：需要进行merge的QueryRunner集合</li>
<li>exec：执行线程池</li>
<li>queryWatcher：用于QueryRunner级别运行时候注册查询。</li>
<li>concurrencyHint：当前jvm可用的cpu数量</li>
<li>mergeBufferPool：用于获取merge时所需要的ByteBuffer空间</li>
<li>mergeBufferSize：merge所需要的size</li>
<li>processingTmpDir：执行merge时使用的临时目录</li>
</ul>
<p>下面开始逐层剖析run方法：</p>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223143477.png" alt="image-20220219223143477"></p>
<ol>
<li><p>判断是否可以使用ChainedExecutionQueryRunner来执行merge操作，前提条件是mergeRunnersUsingChainedExecution参数true或者bysegment参数为true（常用于test测试），使用ChainedExecutionQueryRunner类来执行merge不会申请额外的堆外内存，对某些特俗情况下有利于内存的节约（个人理解）。</p>
</li>
<li><p>构建combiningAggregatorFactories、temporaryStorageDirectory、当前查询优先级以及timeout等信息</p>
</li>
</ol>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223212039.png" alt="image-20220219223212039"></p>
<ol start="3">
<li><p>构建最终的BaseSequence，步骤分为以下几部：</p>
<pre><code>1. 首先初始化资源包括：临时的文件存储（temporaryStorage）  、mergeBuffer（合并结果使用的直接内存buffer）并且将这些资源都添加到resources集合中（用于在执行完成之后释放资源）。
</code></pre>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223244113.png" alt="image-20220219223244113"></p>
<pre><code> 2. 构建grouper和Accumulator。其中grouper作用之前已经讲过，而Accumulator可以看做一个累加器，其中封装了对数据进行累加计算的逻辑，在这里用于对groupby输入数据进行计算逻辑的封装。构建这两个对象使用的方法为RowBasedGrouperHelper.createGrouperAccumulatorPair方法，下面详解一下这个方法：
</code></pre>
</li>
</ol>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223302789.png" alt="image-20220219223302789"></p>
<p>入参列表如图所示，下面看具体实现逻辑.</p>
<ol>
<li>这部分是一些参数的初始化，包括limit信息，key的序列化器，columnSelectorFactory等</li>
</ol>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223320717.png" alt="image-20220219223320717"></p>
<ol start="2">
<li><p>构建grouper，根据concurrencyHint的值来构建grouper，concurrencyHint表示当前机器可用的cpu核数，当concurrencyHint=-1时构建SpillingGrouper，而其他情况构建ConcurrentGrouper来并发的执行grouper逻辑。在底层逻辑中ConcurrentGrouper中也是s维护了一个SpillingGrouper的集合来实现的并行计算，所以实际上他们最终都是使用SpillingGrouper。在SpillingGrouper中，最终使用的是BufferHashGrouper实现的，与BufferHashGrouper不同的是，SpillingGrouper在buffer内存使用满的时候会将之前的数据溢写到磁盘中，然后重置buffer来防止内存不足。</p>
</li>
<li><p>在构建grouper完成之后会构建Accumulator，这之中封装了对row进行处理的逻辑，详细代码如下：</p>
</li>
</ol>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223344867.png" alt="image-20220219223344867"></p>
<p>​    首先会对grouper进行一个init操作，调用columnSelectorFactory.setRow对columnSelectorFactory中的row进行设置，然后构建groupkey，最后调用grouper的aggregate方法进行聚合计算。逻辑比较简单。</p>
<ol start="4">
<li>在对grouper和Accumulator构建完成之后，就会将所有的QueryRunner提交执行了：</li>
</ol>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223413572.png" alt="image-20220219223413572"></p>
<p>通过这段代码将queryRunner集合迭代并且使用构建的Accumulator逻辑进行运算。</p>
<ol start="5">
<li>生成CloseableGrouperIterator并且返回，整个GroupByMergingQueryRunnerV2.run的逻辑就完成了。</li>
</ol>
<p><img src="/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20220219223434957.png" alt="image-20220219223434957"></p>
<h5 id="GroupByQueryQueryToolChest-mergeResults"><a href="#GroupByQueryQueryToolChest-mergeResults" class="headerlink" title="GroupByQueryQueryToolChest.mergeResults"></a>GroupByQueryQueryToolChest.mergeResults</h5><p>​    在完成mergeRunner之后还会调用mergeResults方法,此方法会将结果再进行一次聚合，在broker端和也会调用一次，逻辑是将上两步groupby结果在进行一次聚合。这里不做详细讲解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/19/druid%E4%B8%ADGroupbyQuery%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/" data-id="ckzty1zzy0001qd7978z3gr55" data-title="druid中GroupbyQuery查询流程解析" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/druid/" rel="tag">druid</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/02/19/druid%E4%B8%ADScanQuery%E6%9F%A5%E8%AF%A2%E8%A7%A3%E6%9E%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          druid中ScanQuery查询解析
        
      </div>
    </a>
  
  
    <a href="/2022/02/19/druid%E4%B8%ADTimeseriesQuery%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">druid中TimeseriesQuery的查询源码解析</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ID-MAPPING/" rel="tag">ID-MAPPING</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/druid/" rel="tag">druid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flink/" rel="tag">flink</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ID-MAPPING/" style="font-size: 10px;">ID-MAPPING</a> <a href="/tags/druid/" style="font-size: 20px;">druid</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/20/%E5%9F%BA%E4%BA%8EFlink%E7%9A%84%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E6%8E%A2%E7%B4%A2/">基于Flink的实时数仓探索</a>
          </li>
        
          <li>
            <a href="/2022/02/20/%E5%AE%9E%E6%97%B6ID-Mapping%E6%A0%87%E8%AF%86%E5%94%AF%E4%B8%80%E7%94%A8%E6%88%B7%E6%96%B9%E6%A1%88/">实时ID-Mapping标识唯一用户方案</a>
          </li>
        
          <li>
            <a href="/2022/02/19/druid%E4%B8%ADsql%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/">druid中sql模块分析</a>
          </li>
        
          <li>
            <a href="/2022/02/19/druid%E4%B8%AD%E5%8F%91%E5%B8%83%E5%8D%B8%E8%BD%BDsegment%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">druid中发布卸载segment和服务源码解析</a>
          </li>
        
          <li>
            <a href="/2022/02/19/druid%E4%B8%AD%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">druid中聚合函数实现源码解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Lime<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>